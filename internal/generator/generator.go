package generator

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"sync"
	"text/template"

	"golang.org/x/tools/go/packages"

	"github.com/xehrad/goge/internal/scanner"
)

const fileHeader = `// Code generated by goge; DO NOT EDIT.`

var tpl = template.Must(template.New("handler").Parse(`
	package {{.PkgName}}

	import (
		"github.com/gofiber/fiber/v2"
		{{- range .ExtraImports }}
			"{{ . }}"
		{{- end }}
	)

	type (
		Service interface {
			{{- range .Endpoints }}
				{{ .MethodName }}({{ .InputArg }}) ({{ .ReturnType }}, error)
			{{- end }}
		}

		Handler struct {
			service Service
		}
	)

	func NewHandler(s Service) *Handler { return &Handler{service: s} }

	func (h *Handler) RegisterRoutes(app *fiber.App) {
		{{- range .Endpoints }}
			app.{{ .HTTPMethod }}("{{ .Path }}", h.{{ .MethodName }})
		{{- end }}
	}

	{{- range .Endpoints }}

		func (h *Handler) {{ .MethodName }}(c *fiber.Ctx) error {
		{{- if .InputIsStruct }}
			{{ .ReqAlloc }}
			{{- if .NeedsBodyParser }}
				if err := c.BodyParser(req); err != nil {
					return fiber.ErrBadRequest
				}
			{{- end }}
				{{ .BindingCode }}
				res, err := h.service.{{ .MethodName }}({{ .CallArg }})
		{{- else }}
				// Primitive input; bind from path or query
				{{ .PrimitiveBind }}
				res, err := h.service.{{ .MethodName }}({{ .CallArg }})
		{{- end }}
				if err != nil {
					return err
				}
		{{- if .ReturnIsBytes }}
				return c.Send(res)
		{{- else }}
				return c.JSON(res)
		{{- end }}
		}
	{{- end }}
`))

// internal view model for template
type endpointVM struct {
	MethodName      string
	HTTPMethod      string
	Path            string
	InputArg        string
	ReturnType      string
	ReturnIsBytes   bool
	InputIsStruct   bool
	InputTypeExpr   string
	PrimitiveBind   string
	CallArg         string
	ReqAlloc        string
	BindingCode     string
	NeedsBodyParser bool
}

type pkgVM struct {
	PkgName      string
	ExtraImports []string
	Endpoints    []endpointVM
}

var externalStructCache = struct {
	sync.RWMutex
	structs map[string]map[string]*ast.StructType
	fails   map[string]bool
}{
	structs: map[string]map[string]*ast.StructType{},
	fails:   map[string]bool{},
}

// main entry
func Generate(root string, apis map[string]*scanner.PackageAPIs) error {
	fmt.Printf("[goge] generating handlers in root: %s\n", root)

	for pkgDir, pkg := range apis {
		vm := pkgVM{
			PkgName:      pkg.PkgName,
			ExtraImports: collectImports(pkg),
		}

		for _, ep := range pkg.Endpoints {
			ev := endpointVM{
				MethodName:    ep.MethodName,
				HTTPMethod:    strings.Title(strings.ToLower(ep.HTTPMethod)),
				Path:          ep.Path,
				InputIsStruct: ep.InputIsStruct,
				InputTypeExpr: ep.InputTypeExpr,
				ReturnType:    ep.ReturnTypeExpr,
				ReturnIsBytes: ep.ReturnTypeExpr == "[]byte",
			}

			// detect if BodyParser needed
			method := strings.ToUpper(ep.HTTPMethod)
			if method == "POST" || method == "PUT" || method == "PATCH" {
				ev.NeedsBodyParser = true
			}

			if ep.InputIsStruct {
				paramIsPtr := strings.HasPrefix(ep.InputTypeExpr, "*")
				base := strings.TrimPrefix(ep.InputTypeExpr, "*")

				ev.InputArg = "req " + ep.InputTypeExpr
				ev.ReqAlloc = fmt.Sprintf("req := new(%s)", base)

				// parse struct (local or imported)
				st := findStructAST(root, pkg, base)
				if st != nil {
					binds := ExtractBindingsRecursive(pkg, st)
					ev.BindingCode = BuildBindCode(binds)
				}

				if paramIsPtr {
					ev.CallArg = "req"
				} else {
					ev.CallArg = "*req"
				}
			} else {
				name := pathParamName(ep.Path)
				if name == "" {
					name = "v"
				}
				code, needStrconv := primitiveBind(name, ep.InputTypeExpr)
				ev.PrimitiveBind = code
				ev.InputArg = fmt.Sprintf("%s %s", name, strings.TrimPrefix(ep.InputTypeExpr, "*"))
				ev.CallArg = name
				if needStrconv {
					vm.ExtraImports = append(vm.ExtraImports, "strconv")
				}
			}

			vm.Endpoints = append(vm.Endpoints, ev)
		}

		sort.Slice(vm.Endpoints, func(i, j int) bool { return vm.Endpoints[i].MethodName < vm.Endpoints[j].MethodName })
		sort.Strings(vm.ExtraImports)

		var buf bytes.Buffer
		buf.WriteString(fileHeader)
		if err := tpl.Execute(&buf, vm); err != nil {
			return fmt.Errorf("template exec: %w", err)
		}

		formatted, err := format.Source(buf.Bytes())
		if err != nil {
			return fmt.Errorf("format generated handler: %w", err)
		}
		out := filepath.Join(pkgDir, "handler_gen.go")
		if err := os.WriteFile(out, formatted, 0o644); err != nil {
			return fmt.Errorf("write %s: %w", out, err)
		}
	}
	return nil
}

// --- Helpers ---

func collectImports(pkg *scanner.PackageAPIs) []string {
	need := map[string]bool{}
	for _, ep := range pkg.Endpoints {
		if i := strings.Index(ep.InputTypeExpr, "."); i > 0 {
			alias := strings.TrimPrefix(ep.InputTypeExpr[:i], "*")
			if ip, ok := pkg.Imports[alias]; ok {
				need[ip] = true
			}
		}
	}
	out := make([]string, 0, len(need))
	for k := range need {
		out = append(out, k)
	}
	return out
}

func pathParamName(path string) string {
	i := strings.Index(path, ":")
	if i < 0 {
		return ""
	}
	j := i + 1
	for j < len(path) && (isAlphaNum(path[j]) || path[j] == '_') {
		j++
	}
	return path[i+1 : j]
}

func isAlphaNum(b byte) bool {
	return (b >= 'a' && b <= 'z') || (b >= 'A' && b <= 'Z') || (b >= '0' && b <= '9')
}

// supports primitives like string/int only
func primitiveBind(name, typ string) (string, bool) {
	typ = strings.TrimPrefix(typ, "*")
	switch typ {
	case "string":
		return fmt.Sprintf("%s := c.Params(%q, c.Query(%q, \"\"))", name, name, name), false
	case "int", "int64":
		return fmt.Sprintf(`
		{
			raw := c.Params("%[1]s", c.Query("%[1]s", "0"))
			val, err := strconv.ParseInt(raw, 10, 64)
			if err != nil { return fiber.ErrBadRequest }
			%[1]s := %[2]s(val)
		}`, name, typ), true
	case "float64":
		return fmt.Sprintf(`
		{
			raw := c.Params("%[1]s", c.Query("%[1]s", "0"))
			val, err := strconv.ParseFloat(raw, 64)
			if err != nil { return fiber.ErrBadRequest }
			%[1]s := val
		}`, name), true
	default:
		return fmt.Sprintf("%s := c.Params(%q, c.Query(%q, \"\"))", name, name, name), false
	}
}

// --- AST parsing helpers ---

type astStruct struct {
	Struct *ast.StructType
}

func parseStructAST(pkgDir, structName string) *astStruct {
	fSet := token.NewFileSet()
	files, _ := os.ReadDir(pkgDir)
	for _, f := range files {
		if !strings.HasSuffix(f.Name(), ".go") {
			continue
		}
		filePath := filepath.Join(pkgDir, f.Name())
		node, err := parser.ParseFile(fSet, filePath, nil, parser.ParseComments)
		if err != nil {
			continue
		}
		for _, decl := range node.Decls {
			genDecl, ok := decl.(*ast.GenDecl)
			if !ok {
				continue
			}
			for _, spec := range genDecl.Specs {
				ts, ok := spec.(*ast.TypeSpec)
				if !ok || ts.Name.Name != structName {
					continue
				}
				if st, ok := ts.Type.(*ast.StructType); ok {
					return &astStruct{Struct: st}
				}
			}
		}
	}
	return nil
}

func (a *astStruct) Fields() *ast.FieldList {
	if a == nil || a.Struct == nil {
		return nil
	}
	return a.Struct.Fields
}

func findModuleRoot(dir string) string {
	cur := filepath.Clean(dir)
	for {
		if cur == "" {
			return ""
		}
		if _, err := os.Stat(filepath.Join(cur, "go.mod")); err == nil {
			return cur
		}
		parent := filepath.Dir(cur)
		if parent == cur {
			return ""
		}
		cur = parent
	}
}

func loadStructFromImport(importPath, structName, moduleDir string) *astStruct {
	if importPath == "" || structName == "" {
		return nil
	}

	externalStructCache.RLock()
	if structs, ok := externalStructCache.structs[importPath]; ok {
		if st, ok := structs[structName]; ok {
			externalStructCache.RUnlock()
			return &astStruct{Struct: st}
		}
	}
	if externalStructCache.fails[importPath] {
		externalStructCache.RUnlock()
		return nil
	}
	externalStructCache.RUnlock()

	externalStructCache.Lock()
	defer externalStructCache.Unlock()

	if structs, ok := externalStructCache.structs[importPath]; ok {
		if st, ok := structs[structName]; ok {
			return &astStruct{Struct: st}
		}
	}
	if externalStructCache.fails[importPath] {
		return nil
	}

	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedSyntax | packages.NeedFiles,
	}
	if moduleDir != "" {
		cfg.Dir = moduleDir
	}
	env := os.Environ()
	env = append(env, "GO111MODULE=on")
	cfg.Env = env

	pkgs, err := packages.Load(cfg, importPath)
	if err != nil {
		fmt.Printf("[goge] warning: packages.Load %s failed: %v\n", importPath, err)
		externalStructCache.fails[importPath] = true
		return nil
	}
	if len(pkgs) == 0 {
		externalStructCache.fails[importPath] = true
		return nil
	}

	structs := make(map[string]*ast.StructType)
	for _, p := range pkgs {
		for _, f := range p.Syntax {
			for _, decl := range f.Decls {
				genDecl, ok := decl.(*ast.GenDecl)
				if !ok {
					continue
				}
				for _, spec := range genDecl.Specs {
					ts, ok := spec.(*ast.TypeSpec)
					if !ok {
						continue
					}
					if st, ok := ts.Type.(*ast.StructType); ok {
						structs[ts.Name.Name] = st
					}
				}
			}
		}
	}

	externalStructCache.structs[importPath] = structs
	if st, ok := structs[structName]; ok {
		return &astStruct{Struct: st}
	}
	return nil
}

// findStructAST resolves both local and imported structs using the explicit import paths collected for a package.
func findStructAST(root string, pkg *scanner.PackageAPIs, typeExpr string) *astStruct {
	if typeExpr == "" {
		return nil
	}

	alias := ""
	name := strings.TrimSpace(typeExpr)
	if i := strings.LastIndex(name, "."); i >= 0 {
		alias = name[:i]
		name = name[i+1:]
	}

	if alias == "" {
		return parseStructAST(pkg.PkgDir, name)
	}

	impPath, ok := pkg.Imports[alias]
	if !ok {
		return nil
	}

	moduleDir := findModuleRoot(pkg.PkgDir)
	if moduleDir == "" {
		moduleDir = root
	}
	if moduleDir == "" {
		moduleDir = pkg.PkgDir
	}

	return loadStructFromImport(impPath, name, moduleDir)
}
